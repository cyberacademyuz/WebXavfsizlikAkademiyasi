# Insecure deserialization zaifliklarini exploit qilish

Ushbu bo'limda biz **PHP**, **Ruby** va **JAVA** dasturlash tillaridagi Deserialization misollaridan foydalanib **Insecure Deserialization** zaifliklarini qanday qilib exploit qilish mumkinligini o'rgatamiz. Biz Insecure Deserialization ni exploit qilish odamlar o'ylaganidanda ancha muncha osonroq ekanligiga umid qilamiz.

Va yana sizga o'zingizning deserialization ga asoslangan katta xujumlaringizni qanday amalga oshirishingiz mumkin ekanligini o'rgatamiz. Garchi bularni amalga oshirish uchun sizga source code ga kirish kerak bo'lsada, ularni asosiy konseptsiyalarini o'rganganingizdan so'ng buni amalga oshirish osonroq bo'ladi. Ayniqsa biz quyidagi mavzularga bor e'tiborimizni qaratamiz:

* [<mark style="color:yellow;">Qanday qilib Insecure Deserialization ni aniqlash mumkin</mark>](insecure-deserialization-zaifliklarini-exploit-qilish.md#qanday-qilib-insecure-deserialization-ni-aniqlash-mumkin)
* [<mark style="color:yellow;">Web sayt kutgan serialized obyektlarga o'zgartirish kiritish</mark>](insecure-deserialization-zaifliklarini-exploit-qilish.md#web-sayt-kutgan-serialized-obyektlarga-ozgartirish-kiritish)
* [<mark style="color:yellow;">Zararli ma'lumotni web saytning xavfli funksionalligiga qo'shish</mark>](insecure-deserialization-zaifliklarini-exploit-qilish.md#websayt-funksionalligi-ozgartirish)
* O'zboshimchalik bilan obyektlarni qo'shish
* Xavfli sink gadjetlariga ma'lumotlar oqimini boshqarish uchun zanjirli usul chaqiruvlarini amalga oshirish
* Qo'lbola o'zingizni Deserialization exploitingizni yaratish
* PHAR Deserialization

{% hint style="info" %}
**Eslatma:**

Garchi juda ko'p laboratoriyalar PHP asosida bo'lsada, bu usullar boshqa dasturlash tillarida ham shunday amalga oshiriladi.
{% endhint %}

## <mark style="color:yellow;">Qanday qilib Insecure Deserialization ni aniqlash mumkin ?</mark> <a href="#qanday-qilib-insecure-deserialization-ni-aniqlash-mumkin" id="qanday-qilib-insecure-deserialization-ni-aniqlash-mumkin"></a>

Insecure Deserialization ni aniqlash judayam sodda hisoblanadi. Audit paytida siz web-saytga uzatilayotgan barcha ma'lumotlarni ko'rib chiqishingiz va **Serialized** ma'lumotlarga o'xshash narsalarni aniqlashga harakat qilishingiz kerak. Agar siz ularning formatini turli dasturlash tillarida qanday ishlatilishini bilsangiz Serialized ma'lumotlarni tezda topishingiz mumkin. Bu bo'limda biz **PHP** va **Java** dasturlash tillarida serialized ma'lumotlardan misollar ko'rsatamiz. Agar serialized ma'lumotni aniqlasangiz uni xohlaganingizcha test qilishingiz mumkin, chunki siz uni boshqara olasiz.

{% hint style="success" %}
**Maslahat**

[<mark style="color:yellow;">Burp Scanner</mark>](https://portswigger.net/burp/vulnerability-scanner) [<mark style="color:yellow;">Burp Suite Proffessional</mark>](https://portswigger.net/burp/pro) foydalanuvchilarini HTTPning request va response xabarlarida serialized ma'lumotlar borligini flag bilan ogohlantiradi.
{% endhint %}

### <mark style="color:yellow;">PHP serialization format</mark> <a href="#php-serialization-format" id="php-serialization-format"></a>

PHP, har bir obyektnining uzunligini matn va raqamlar orqali ifodalab inson tushuna oladigan string formatidan foydalanadi. Masalan, `User` obyektini, attributlari bilan ko'rib chiqaylik:

```php
$user->name = "carlos";
$user->isLoggedIn = true;
```

Qachonki u serialized malumotga o'tkazilsa quyidagicha ko'rinishga keladi:

```php
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
```

Buni mana bunday ajratib tariflash mumkin:

* `O:4:"User"` - 4 ta belgidan iborat `User` nomli klassga ega obyekt
* `2` - u obyektda 2 ta attribut bor
* `s:4:"name"` - birinchi attributni kaliti 4 ta belgidan iborat va u `name`
* `s:6:"carlos"` - birinchi attributni qiymati 6 ta belgidan iborat va u `carlos`
* `s:10:"isLoggedIn"` - ikkinchi attributni kaliti 10 ta belgidan iborat va u `isLoggedIn`
* `b:1` - ikkinchi attributning qiymati boolean qiymat bo'lib u: `true`

Serialization uchun PHP ning nativ metodlari bu `serialize()` va `unserialize()` hisoblanadi. Agarda sizda source code-ga kirish imkoniyati bo'lsa, unda siz koddan `unserialize()` metodidan foydalanilgan har qanday qismni topishingiz kerak.

### <mark style="color:yellow;">Java Serialization format</mark> <a href="#java-serialization-format" id="java-serialization-format"></a>

Ba'zi dasturlash tillari, Java ham, ikkilik sanoq sistemasiga asoslangan serialization formatlaridan foydalanadi. Bu ma'lumotlarni o'qish uchun ancha muncha qiyinchilik tug'diradi, Java obyektlari har doim encodelangan `ac ed` hexadecimal va `r00` Base64 kabi bir xil baytlar bilan boshlanadi.

Har qanaqa tur uchun serialized yoki deserialized obyekt yasash uchun siz `java.io.Serializable` ni amalga oshirishingiz mumkin. Agarda sizda source code-ga kirish imkoni bo'lsa unda siz `InputStream` dan kiruvchi ma'lumotlarni deserialize qiladigan `readObject()` metodiga e'tiboringizni qarating.

## <mark style="color:yellow;">Web sayt kutgan serialized obyektlarga o'zgartirish kiritish</mark> <a href="#web-sayt-kutgan-serialized-obyektlarga-ozgartirish-kiritish" id="web-sayt-kutgan-serialized-obyektlarga-ozgartirish-kiritish"></a>

Ba'zi deserialization zaifliklarini serialized obyektning attributlarini o'zgartirgan holda exploit qilish mumkin. Obyekt steyti doimo bir xil bo'lgani sabab, siz uni serialized holatini o'rganishingiz va undagi attributlarni tahrirlashingiz mumkin. Buni amalga oshirish bosqichi deserialization ni exploit qilishning boshlang'ich konsepsiyasi hisoblanadi.

Batafsilroq aytadigan bo'lsak serialized obyektni manipulatsiya qilishingiz uchun sizda ikkita yondashuv usuli bor. Siz uni to'g'ridan to'g'ri o'zgartirishingiz yoki mos keladigan dasturlash tilida skript yozib obyekt ichida yana obyekt tuzishingiz mumkin. Ikkinchi yondashuv usulini ikkilik sanoq sistemasida ishlaydigan serialization-da ishlatish qulay hisoblanadi.

### <mark style="color:yellow;">Obyekt attributlarini o'zgartirish</mark> <a href="#obyekt-attributlarini-ozgartirish" id="obyekt-attributlarini-ozgartirish"></a>

Ma'lumotni buzayotganda Haker valid bo'lgan serialized obyektni saqlab qola olsa, deserialization bo'layotganda attributlarning o'zgargan holatidagi, server-side obyekt hosil bo'ladi.

Bunga oddiy misol, cookie faylida foydalanuvchi sessiyasi haqidagi ma'lumotlarni saqlash uchun serialized `user` obyektidan foydalanadigan veb-saytni ko'zdan kechiring. Agar Haker uni HTTP request yuborish paytida aniqlasa, uni decode qilishi mumkin:

```php
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
```

`isAdmin` attributi qiziqarli ko'rinmoqda. Haker undagi `b:0;` qiymatini `b:1;` ga o'zgartirib re-encode qilib qayta cookie ga joylab jo'natib admin bo'lishi mumkin. Izolyatsiyada, bu hech qanday ta'sir ko'rsatmaydi. Biroq, deylik, web-sayt ushbu cookie-fayldan joriy foydalanuvchining ma'lum administrativ funksiyalarga kirish huquqini tekshirish uchun foydalanadi:

```java
$user = unserialize($_COOKIE);
if ($user->isAdmin === true) {
//administrator paneliga kirishga ruxsat berish
}
```

Ushbu zaif kodda Haker tomonidan isAdmin attributiga o'zgartirish kiritilgan `User` obyektidagi ma'lumotni cookie deb o'rnatadi. Bunda hech qanday holatda serialized qilingan obyektlarning haqiqiyligi tekshirilmaydi. Keyin bu ma'lumot steyt tekshiruvidan o'tadi va osonlikcha imtiyozlarni oshirish imkonini beradi, ya'ni oddiy foydalanuvchi admin ga aylanadi.

Bu oddiy usul real hayotda unchalik ham keng tarqalmagan. Ammo attributlarni o'zgartirish **Insecure Deserialization** xujumlarini katta qismini birinchi qadami hisoblanadi.

{% hint style="warning" %}
<mark style="color:yellow;">**Lab:**</mark> [Obyekt attributlarini o'zgartirish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects)
{% endhint %}

### <mark style="color:yellow;">Ma'lumot turlarini o'zgartirish</mark> <a href="#malumot-turlarini-ozgartirish" id="malumot-turlarini-ozgartirish"></a>

Biz obyektlarning attribut qiymatlarini qanday qilib o'zgartirish mumkinligini ko'rib chiqdik, bundan tashqari yana web sayt kutmagan ma'lumot turlarni ham yuborishimiz mumkin.

PHPda turli malumot turlarini taqqoslashda == taqqoslash operatorining xatti harakatlari tufayli bu kabi manipulatsiyaga zaif hisoblanadi. Masalan siz integer va stringni taqqoslayotganingizda PHP stringni integer-ga aylantirishga harakat qiladi, ya'ni bu 5 == "5" true qiymatini berishini anglatadi.

Odatdagidek, bu raqam bilan boshlanadigan har qanday alfanumerik string uchun ham ishlaydi. Bu holatda PHP stringdagi raqamni to'g'ridan to'g'ri integerga o'zgartiradi. Stringning qolgan qismiga esa ahamiyat berilmayd. Bundan kelib chiqadiki `5 == "5 of something"` qiymatlarni taqqoslash 5 == 5 bo'ladi.

Yana bir g'alati taqqoslash bu, har qanday stringni 0 raqami bilan taqqoslasangiz paydo bo'ladi:

```
0 == "Example string" // true
```

Nega bunday ? Chunki bu yerda raqam yo'q va taqqoslanayotgan raqam bu nol, stringda esa raqamlar soni nolta, ya'ni umuman yo'q bo'lgani uchun.

Keling foydalanuvchini tomonidan kiritilgan ma'lumotlarni to'g'ri yoki noto'g'riligini tekshiruvchi funksiyada aynan ushbu taqqoslash usulidan foydalanilgan bo'lsa nima bo'ladi deb o'ylaysiz ? Bu juda xavfli hisoblanadi.

```php
$login = unserialize($_COOKIE)
if ($login['password'] == $password) {
// log in successfully
}
```

Deylik Haker password attributini string o'rniga 0 raqami bilan o'zgartirdi. Bilamizki parol hech qachon raqam bilan boshlanmaydi va bu holatda holatni tekshiruvchi funksiya har doim true qaytaradi va bu avtorizatsiyani aylanib o'tish imkonini beradi. E'tibor bering, bu faqat deserialization, ma'lumot turini saqlaganligi sababli shunday. Agar kod parolni to'g'ridan to'g'ri qabul qilib uni stringga aylantirsa unda holat tekshiruvchi funksiya `false` qaytaradi.

Shuni yodda tutingki, har qanday serialized obyekt formatida ma'lumot turlari o'zgartirilsa, serialized ma'lumotlardagi har qanday turdagi belgilarni va uzunlik indikatorlarini update qilishni ham unutmaslik kerak. Aks holda, serialized obyekt buziladi va deserialization qilinmaydi.

{% hint style="warning" %}
<mark style="color:yellow;">**Lab:**</mark> [Serialized ma'lumot turlarini o'zgartirish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types)
{% endhint %}

Agar siz ikkilik sanoq sistemasidagi serialized obyektlar bilan ishlayotgan bo'lsangiz unda sizga [Hackvertor extension](https://portswigger.net/bappstore/65033cbd2c344fbabe57ac060b5dd100)idan foydalanishni maslahat beramiz. Siz Hackvertor bilan serialized obyektni oddiy string kabi o'zgartirishingiz mumkin va u avtomatik tarzda o'zgargan ikkilik tizimiga o'tadi. Bu sizni ko'pgina qo'lda sinab ko'rishlardan asraydi.

### <mark style="color:yellow;">Websayt funksionalligi o'zgartirish</mark> <a href="#websayt-funksionalligi-ozgartirish" id="websayt-funksionalligi-ozgartirish"></a>

Shunchaki atribut qiymatlarini tekshirish bilan bir qatorda, web-sayt funksionalligi deserialized obyekt ma'lumotlari ustida xavfli operatsiyalarni ham bajarishi mumkin. Bunday holda, siz kutilmagan ma'lumotlarni uzatish va zarar yetkazish maqsadida tegishli funktsiyalardan foydalanish uchun insecure deserialization-dan foydalanishingiz mumkin.

Masalan, web-saytning "Foydalanuvchini o'chirish" funksiyasining bir qismi sifatida foydalanuvchining profil rasmi `$user->image_location` atributidagi fayl joylashuviga kirish orqali o'chiriladi. Agar bu `$user` serialized obyektdan yaratilgan boʻlsa, haker buni o'zgartirilgan obyektda, fayl joylashuvi o'tnatilgan `image_location` bilan aylanib o'tish orqali exploit qilishi mumkin. Foydalanuvchi o'z hisobini o'chirish bilan birgalikda ushbu faylni ham o'chiradi.

{% hint style="warning" %}
<mark style="color:yellow;">**Lab:**</mark> [Insecure deserialization-ni exploit qilishda websayt funksionalligidan foydalanish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-using-application-functionality-to-exploit-insecure-deserialization)
{% endhint %}

Ushbu misol hakerning xavfli metodni foydalanuvchi tomonidan boshqariladigan funksiyalar orqali qo'lbola tarzda amalga oshirishga tayanadi. Biroq, ma'lumotlarni xavfli metodlarga avtomatik ravishda o'tkazadigan exploitlarni yaratganingizda,insecure deserialization yanada qiziqarli bo'ladi. Bu "sehrli usullar" dan foydalanish orqali amalga oshiriladi.

### <mark style="color:yellow;">Magic metodlar</mark> <a href="#magic-metodlar" id="magic-metodlar"></a>

Magic (yoki dunder) metodlar, metodlarning maxsus to'plami bo'lib, siz ularni ishga tushirish uchun chaqirishingiz shart emas. Ularning o'zi ma'lum bir amal bajarilganda avtomatik tarzda chaqiriladi. Magic metodlar turli tillarda OOPning umumiy xususiyati hisoblandi. Ular ba'zan prefiks qo'yish yoki metod nomini ikkita pastki chiziq orasida yozish orqali ko'rsatiladi.&#x20;

Ma'lum bir hodisa sodir bo'lganda qanday kod bajarilishi kerakligini oldindan belgilash uchun dasturchilar klassga magic metodlarni qo'shishlari mumkin. Aynan qachon va nima uchun magic metoddan foydalanish har bir metodda har xil bo'ladi. PHPdagi eng keng tarqalgan misollardan biri `__construct()` bo'lib, u har safar klass obyekti yaratilganda chaqiriladi, huddi Pythondagi `__init__` kabi. Odatda, constructor kabi, magic metodlar obyektning atributlarini ishga tushirish uchun kodni o'z ichiga oladi.

Biroq, magic metodlar dasturchilar tomonidan istalgan kodni bajarish uchun moslashtirilishi mumkin. Magic metodlar keng qo'llaniladi va o'z-o'zidan zaiflikni keltirib chiqarmaydi. Ammo ular bajarayotgan kod haker tomonidan boshqariladigan ma'lumotlarni, masalan serialized obyekt orqali ishga tushsa xavfli bo'lishi mumkin. Agar hacker conditionlarga mos keluvchi shartlarni bajarsa serialized ma'lumotlarda metodlarni avtomatik ravishda chaqirish uchun foydalanishi mumkin.&#x20;

Bu yerdagi eng muhim narsa shuki ba'zi dasturlash tillari deserialization jarayonida magic metodlarni chaqiradilar. Masalan PHP ning unserialize() metodi obyektning \_\_wakeup() magic metodini qidiradi va uni chaqiradi.

Javadagi deserializationda xuddi shu narsa birinchi bayt oqimidan ma'lumotlarni o'qish uchun ishlatiladigan `ObjectInputStream.readObject()` metodiga taalluqlidir va asosan serialized obyektni "qayta ishga tushirish" uchun konstruktor vazifasini bajaradi. Biroq Serializable klasslar o'zining readObject() metodini quyidagi tarzda e'lon qilishlari mumkin:

```
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
{
    // implementation
}
```

Aynan shu tarzda e'lon qilingan readObject() metodi deserialization paytida chaqiriladigan magic metod sifatida ishlaydi. Bu klassga o'z maydonlarining deserialization bo'lishini yanada diqqat bilan boshqarish imkonini beradi.&#x20;

Ushbu turdagi magic metodlarni o'z ichiga olgan har qanday klasslarga e'tibor berishingiz kerak. Ular obyekt to'liq deserialization bo'lguniga qadar serialized obyektdan ma'lumotlarni web-sayt kodiga o'tkazishga imkon beradi. Bu yanada rivojlangan ekspluatatsiyalarni yaratish uchun boshlang'ich nuqtadir.

## <mark style="color:yellow;">Ixtiyoriy obyektlarni kiritish</mark>

Ixtiyoriy obketlarni qo'shish

Ko'rib turganimizdek, ba'zan veb-sayt tomonidan taqdim etilgan obyektni oddiygina tahrirlash orqali insecure deserializationni exploit qilishimiz mumkin. Biroq, ixtiyoriy obketlarni qo'shish'shish ko'plab imkoniyatlarni ochadi.

OOPda obyekt uchun mavjud bo'lgan metodlar uning klassiga qarab belgilanadi. Shu sababli, agar hacker serialized ma'lumotlar sifatida qaysi obyekt klassini uzatilayotganini manipulyatsiya qila olsa, ular serialized bo'lganidan keyin va hatto deserialization qilish paytida ham qanday kod ishga tushishiga ta'sir qilishi mumkin.

Deserialization metodlari, odatda deserialization qilingan narsalarni tekshirmaydi. Bu shuni anglatadiki, siz web-saytda mavjud bo'lgan har qanday seriyali klass obyektlariga o'tishingiz mumkin va obyekt deserialized qilinadi. Bu hakerga ixtiyoriy klasslar misollarini yaratishga samarali imkon beradi. Ushbu obyekt kutilgan klassga tegishli emasligi muhim emas. Kutilmagan obyekt turi web sayt logikasida istisnoga olib kelishi mumkin, ammo zararli obyekt allaqachon yaratilgan bo'ladi.

Agar haker source kodga kirish imkoniga ega bo'lsa, ular barcha mavjud klasslarni batafsil o'rganishi mumkin. Oddiy ekspluatatsiyani yaratish uchun ular deserializationning magic metodlarini o'z ichiga olgan klasslarni izlaydilar, so'ngra ulardan birortasi boshqariladigan ma'lumotlar ustida xavfli operatsiyalarni bajarishini tekshiradi. Keyin haker ekspluatatsiya uchun magic metoddan foydalanish uchun ushbu klassning serialized obyektiga o'tishi mumkin.

{% hint style="warning" %}
<mark style="color:yellow;">**Lab:**</mark> [PHPda ixtiyoriy obyektlarni kiritish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-arbitrary-object-injection-in-php)
{% endhint %}

Ushbu deserialization magic metodlarini o'z ichiga olgan klasslar, "gadjet zanjiri" deb nomlanuvchi,  metod chaqiruvlarining uzun seriyasini o'z ichiga olgan murakkabroq hujumlarni boshlash uchun ishlatilishi mumkin.

## <mark style="color:yellow;">Gadjet bog'lamlari</mark>
"Gadjet" - bu hackerga ma'lum bir maqsadga erishishda yordam beradigan web saytda mavjud bo'lgan kod snippeti. Individual gadjet foydalanuvchi inputi bilan bevosita hech qanday zararli ish qilmasligi mumkin. Hackerning maqsadi shunchaki o'z ma'lumotlarini boshqa gadjetga o'tkazadigan metodni ishga tushirish bo'lishi mumkin. Shu tarzda bir nechta gadjetlarni bir-biriga bog‘lash orqali hacker o‘z ma’lumotlarini xavfli “gadjet metod”iga o‘tkazishi mumkin, bu esa maksimal darajada zarar berishi mumkin.

Shuni tushunish kerakki, ba'zi boshqa ekspluatatsiya turlaridan farqli o'laroq, gadjetlar bog'lami hacker tomonidan tuzilgan bir biriga bog'langan metodlarning payloadi emas. Barcha kodlar allaqachon web-saytda bor. Hacker nazorat qiladigan yagona narsa - bu gadjetlar zanjiriga uzatiladigan ma'lumotlardir. Bu odatda, deserialization paytida qo'llaniladigan magic metod yordamida amalga oshiriladi, ba'zida "kick-off gadget" deb nomlanadi.

Tashqarida faqat gadjet bo'g'lamidan foydalanish orqali  ko'plab xavfli deserialization zaifliklaridan foydalanish mumkin bo'ladi. Bu ba'zan oddiy bir yoki ikki bosqichli janjir bo'lishi mumkin, ammo yuqori darajadagi jiddiy xujumlarni yaratish, ehtimol obyekt namunalari va metodlarni chaqirishning yanada murakkab ketma-ketligini talab qiladi. Shu sababli, gadjetlar bog'lamlarini yaratish imkoniyati  insecure deserializationdan muvaffaqiyatli foydalanishning asosiy jihatlaridan biridir.

## <mark style="color:yellow;">Oldindan yaratilgan gadjet bo'g'lami bilan ishlash</mark>

Gadget bog'lamlarini qo'lda aniqlash juda mashaqqatli jarayon bo'lishi mumkin va manba kodiga kirmasdan turib aniqlash deyarli imkonsizdir. Yaxshiyamki, avval sinab ko'rishingiz mumkin bo'lgan oldindan yaratib qo'yilgan gadjet bo'g'lamlari bilan ishlashning bir nechta usullari bor.

Boshqa web-saytlarda muvaffaqiyatli foydalanilgan bir qator oldindan tuzilgan bog'lamlarni taqdim qiladigan bir nechta vositalar mavjud. Harro manba kodiga kirish imkoniga ega bo'lmasangiz ham, ushbu vositalardan nisbatan kamroq kuch sarflagan holda insecure deserialization  zaifliklarini aniqlash va ulardan foydalanishingiz mumkin. Ushbu yondashuv ekspluatatsiya qilinadigan gadjet bog'lamlarini o'z ichiga olgan kutubxonalardan keng foydalanganligi sababli samarali bo'ladi. Misol uchun, agar Java-ning Apache Commons Collections kutubxonasidagi gadjetlar zanjiri bitta web-saytda ishlatilishi mumkin bo'lsa, ushbu kutubxonani amalga oshiradigan boshqa web-saytlar ham xuddi shu zanjir yordamida ishlatilishi mumkin.
